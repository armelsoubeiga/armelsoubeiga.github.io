---
title: "<span><u>Douleur Chronique</u> : typologies de parcours de soins et caractérisation des profils patients</span>"
subtitle: "<u>Projet eDOL</u>" # only for html output
author: "Armel Soubeiga - LIMOS"
date: "`r Sys.Date()`"
output:
  tufte::tufte_html: 
    toc: true
  tufte::tufte_handout:
    citation_package: natbib
    latex_engine: xelatex
  tufte::tufte_book:
    citation_package: natbib
    latex_engine: xelatex
bibliography: skeleton.bib
link-citations: yes
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
library(tufte)
# invalidate cache when the tufte version changes
knitr::opts_chunk$set(cache.extra = packageVersion('tufte'))
options(htmltools.dir.version = FALSE)

#==> Importation library
library(caret)
library(cluster)
library(RColorBrewer)
library(tidyverse)
library(purrr)
library(ggplot2)
library(randomForest)
library(Rdimtools)
library(evclust)
library(gridExtra)
library(factoextra)
library(ggpubr)
library(grid)
library(reshape2)
library(RColorBrewer)
library(WeightedCluster)
library(labelled)
library(gtsummary)
library(gt)
library(fpc)
library(pheatmap)
library(labelled)

library(knitr)
library(xtable)
options(xtable.comment = FALSE)

#source("scripts.R")
source("../OTHERS_Functions.R")
```

</br>

# Contexte

![](figs/intro.png)

```{marginfigure}
Le parcours de santé des patients souffrant de douleur chronique est multiple ce qui entraîne des résultats médiocres en terme d’amélioration de leur santé. 
```

```{marginfigure}
L’identification des profils de ces patients permettrait aux corps médical d’améliorer les résultats de soins et de mieux soutenir ces patients. Nous proposons une approche par regroupement des typologies de parcours de soins et d'identification des profils.
```

<br/>

# Approche 

![](figs/edol_approche1.png)
<br/><br/>

# Analyses descriptives des barométriques

* Auto-questionnaires: des données évaluant les symptômes, les comorbidités et les états psychologiques et physiologiques liés à la douleur chronique. Ces questionnaires sont remplis trimestriellement ou semestriellement par le patient.

* Questionnaires personnels: des données socio-démographiques, de comportement de vie et professionnelles, remplies une seule fois par le patient à l'inclusion dans l'étude.

* Questionnaires barométriques d'évaluation de la douleur, la fatigue, le moral, le stress, le sommeil, le confort corporel, l'activité sportive et non-sportive. Ces données sont collectées hebdomadairement.

<br/>

```{r, echo=FALSE, warning=FALSE, message=FALSE}
dff <- read.csv("../input/result-ArmelSoubeiga-barometres.csv", encoding="UTF-8",stringsAsFactors=FALSE, na.strings=c("NA","NaN", " "))
```


```{r,echo=F}
tbl <- t(round(psych::describe(df[,-c(1,2)],quant=c(.25,.75),skew = F, check=F, na.rm = F),2))
tbl %>% kable()
```

```{marginfigure}
Tendance : en moyenne, les scores pour la douleur et la fatigue sont relativement élevés, tandis que les scores pour le stress et l'activité sportive sont relativement bas.
```

</br>

```{marginfigure}
Dispersion : Selon l'sd, l'activité sportive et non-sportive sontrelativement plus dispersées que les autres barométre. Donc ces variables auront un effet dominant par rapport aux autres.
```

</br>

```{r,echo=F, warning=FALSE,fig.width=14, fig.cap = "Visualisation des baromètres"}
df <- dff[,-c(1,2)]
my_labels <- c(douleur="Pain",stress="Stress",fatigue="Fatigue",
               sommeil="Sleep",moral="Mood",
               confort_corpo="Body comfort",
               act_non_sport="Non-sport activities",
               act_sport="Sport activities")
df <- set_variable_labels(df, .labels = my_labels)
df <- as.data.frame(lapply(df, as.numeric))
ggplot(stack(df), aes(x = ind, y = values)) +
  stat_boxplot(geom = "errorbar", width = 0.5, colour = "#3366FF") +
  geom_boxplot(fill = "white", colour = "#3366FF") +
  stat_summary(fun = mean, geom = "point", shape = 18, size = 3, color = "#3366FF") +
    xlab(NULL) + ylab("  ") +
    theme_bw() +
    scale_x_discrete(labels=my_labels) +
    theme(panel.grid.major = element_blank(),
          panel.border = element_blank()) + 
  theme(panel.background = element_rect(fill = '#fffff8'),
        plot.background = element_rect(fill = "#fffff8"))
```


Les baromètres sont ne sont visiblement pas corrèles entre eux. Cependant, les relations causales linéaires impliquent que les scores de la fatigue, le stress et la douleur vont dans le même sens, tandis que le sommeil, le confort corporel et le moral ont également un sens positif.

</br>

```{r,echo=F, warning=FALSE, message=FALSE, fig.width=12, fig.height=6}
GGally::ggpairs(df)  +
    theme(panel.background = element_rect(fill = '#fffff8'),
          plot.background = element_rect(fill = "#fffff8"),
          panel.border = element_blank())
  
```

<br/><br/>

# Transformation et sélection des caratéristiques des barométriques

Nous avons comparé deux algorithmes de sélection non supervisés (unsupervised selection) de variables. En se basant sur la méthode du coude (elbow method) sur les courbes de performance, nous avons puis identifier 7 sélections optimales pour chaque algorithme.


<br/>

```{r,echo=F, warning=FALSE, message=FALSE, fig.width=12, fig.height=8}
load("../input/select/model_data.Rdata")
varimp_rf <- f.importance(rf, colnames(df_features[,-1]))
varimp_lscore <- f.importance(lscore, colnames(df_features[,-1]))

prf <- plot.importance(varimp_rf,50,TRUE,"Random Forest feature selection")
plscore <- plot.importance(varimp_lscore,50,FALSE,"Laplace Score feature selection")

grid.arrange(prf, plscore, ncol = 2)
```

<br/>


```{r,echo=F, warning=FALSE, message=FALSE, fig.width=12, fig.height=8}
load("../input/select/cluster_slect_Rel_FALSE.Rdata")
df_res <- do.call(rbind, mapply(transform, res, ID=seq_along(res), SIMPLIFY = FALSE))
data <-  df_res %>% mutate_if(is.factor, as.character)
data$index <- 1:nrow(data)
flag<- data$index[which.max(data$ASW)]
Visualisation(data,flag, title='ECM with Euclidean distance')
```


<br/><br/>

# Clustering des parcours de soins

## Parametres du modèle

```{r,echo=F, warning=FALSE, message=FALSE}
load("../input/select/cluster_slect_Rel_FALSE.Rdata")
flag<- 2
var <- var[[flag]]
clus.ecm <- ml[[flag]]
data <- cbind.data.frame(user_uuid=df_features[,1],df_features[,var])
C <- 2
```

```{r,echo=F, warning=FALSE, message=FALSE}
summary(clus.ecm)
var
```

<br/>

## Les statistiques du modèle ECM

<br/>

```{r,echo=F, warning=FALSE, message=FALSE}
mas <-  as.data.frame(clus.ecm$mass)
Cluster <- as.numeric(as.factor(colnames(mas)[apply(mas,1,which.max)]))
ecm_stats <- cluster.stats(dist(data[,var], method = "manhattan"),  Cluster)
ecm_stats_ <- do.call(rbind.data.frame, ecm_stats)
colnames(ecm_stats_) <- c("cl_1","cl_2","Cl_incertains")
round(ecm_stats_,digits=2) %>% filter(row.names(ecm_stats_) %in% c('cluster.size', 'noisen','diameter','average.distance','clus.avg.silwidths','dunn')) %>% kable()
```


<br/>

## Etude de la silhoutte

L'analyse de silhouette mesure la qualité du regroupement d'une observation et estime la distance moyenne entre les regroupements :

- Une valeur proche de 1 indique que l'objet est bien groupé. Autrement dit, l'objet
est similaire aux autres objets de son groupe.

- Une valeur de proche de -1 indique que l'objet est mal regroupé et que l'affectation à un autre cluster améliorerait probablement les résultats globaux.

```{r,echo=F, warning=FALSE, message=FALSE}
ss <- avg_silhouette(clus.ecm,data[,-1])
fviz_silhouette(ss, label = FALSE) +
  theme_bw()+
  theme(panel.grid.major = element_blank(),
        panel.border = element_blank()) + 
  theme(panel.background = element_rect(fill = '#fffff8'),
        plot.background = element_rect(fill = "#fffff8"))
```

On constate que plusieurs observations, ont un coefficient de silhouette négatif. Cela signifie qu'ils ne sont pas dans le bon cluster.



## Les patients à silhouette négative

```{r,echo=F, warning=FALSE, message=FALSE}
neg_sil_index <- which(ss[, 'sil_width'] < 0)
sss <-  as.data.frame(ss[neg_sil_index, , drop = FALSE])
tab <- table(sss$cluster, sss$neighbor)
p <- pheatmap(tab, display_numbers = T, 
         color = colorRampPalette(c('white','red'))(3), angle_col=0,
         fontsize_row=14, fontsize_col=14, number_format="%.0f",
         fontsize_number=12,legend=F) 
grid.draw(rectGrob(gp=gpar(fill="#fffff8", lwd=0)))
grid.draw(p)
```


## Visualisation des typologies 

```{r,echo=F, warning=FALSE, message=FALSE}
##### Visualisation
mas <- as.data.frame(clus.ecm$mass)
result <- c()
for (i in 1:C) {
  if (i == 1) {result <- c(result, '1')}
  else if(i == 2){result <- c(result, '2')}
  else{result <- c(result,as.character(i), paste0(i, '_',1:(i-1)))}
}
colnames(mas) <- c("Cl_atypique", result, "Cl_incertains")
mas$Cluster <- colnames(mas)[apply(mas,1,which.max)]
df_select_y <- cbind.data.frame(data, Cluster=as.factor(mas$Cluster))
```

<br/>

```{r,echo=F, warning=FALSE, message=FALSE}
# ACP
pca_res <- prcomp(data[,-1], scale. = F)
ind.coord <- as.data.frame(get_pca_ind(pca_res)$coord)
eigenvalue <- round(get_eigenvalue(pca_res), 1)
variance.percent <- eigenvalue$variance.percent
ind.coord$Cluster <- df_select_y$Cluster

#Plot
pcolor <- colorspace::qualitative_hcl(as.numeric(length(unique(df_select_y$Cluster))), "Dark2")
ggscatter(
  ind.coord, x = "Dim.1", y = "Dim.2", 
  color = "Cluster", palette = pcolor ,  ellipse = F, 
  xlab = paste0("Dim 1 (", variance.percent[1], "% )" ),
  ylab = paste0("Dim 2 (", variance.percent[2], "% )" ),
  mean.point = TRUE, star.plot = TRUE) +
  stat_mean(aes(color = Cluster), size = 5) +
  theme_bw()+
    theme(panel.grid.major = element_blank(),
          panel.border = element_blank()) + 
  theme(panel.background = element_rect(fill = '#fffff8'),
        plot.background = element_rect(fill = "#fffff8"))
```

<br/>

## Visualisation des typologies sur l'ACP 

```{r,echo=F, warning=FALSE, message=FALSE}
#biplot
fviz_pca_biplot(pca_res, label = "var",addEllipses=F, 
          geom.ind = "point",pointshape = 21,pointsize = 2.5,labelsize = 2,
          fill.ind = ind.coord$Cluster) +
  theme_bw()+
    theme(panel.grid.major = element_blank(),
          panel.border = element_blank()) + 
  theme(panel.background = element_rect(fill = '#fffff8'),
        plot.background = element_rect(fill = "#fffff8"))
```

<br/>

## Visualisation hiérarchique des clusters

```{r,echo=F, warning=FALSE, message=FALSE, figures-side, fig.show="hold", out.width="50%"}
# Hierarchical clustering visualisation
hc.res <- eclust(data[,-1], "hclust", k = 3, hc_metric = "euclidean", 
                 hc_method = "ward.D2", graph = FALSE)
fviz_dend(hc.res, show_labels = FALSE, type = "phylogenic", palette = pcolor,
          phylo_layout = "layout_as_tree") + theme_bw() +
    theme(panel.grid.major = element_blank(),
          panel.border = element_blank()) + 
  theme(panel.background = element_rect(fill = '#fffff8'),
        plot.background = element_rect(fill = "#fffff8"))

fviz_dend(hc.res, show_labels = FALSE, type = "phylogenic", palette = pcolor,
          phylo_layout = "layout_with_lgl") + theme_bw() +
    theme(panel.grid.major = element_blank(),
          panel.border = element_blank()) + 
  theme(panel.background = element_rect(fill = '#fffff8'),
        plot.background = element_rect(fill = "#fffff8"))
```


<br/><br/>

# Analyse de l'impact du clusters incertaines sur la qualité du clustering

```{r,echo=F, warning=FALSE, message=FALSE}
df_suivi <- df_select_y

df_names <- read.csv("../input/db_patients.csv", encoding="UTF-8",stringsAsFactors=FALSE)
df_names$uuid_patient <- gsub('-','',df_names$uuid_patient)
names(df_names)[1] <- 'user_uuid'
df_fusion <- merge(df_names, df_suivi, by="user_uuid",all.y =TRUE)
df_fusion2 <- df_fusion
```

<br/>

## Analyse avancée de la silhoutte

```{r,echo=F, warning=FALSE, message=FALSE}
mas <-  as.data.frame(clus.ecm$mass)
mas$Cluster <- as.numeric(as.factor(colnames(mas)[apply(mas,1,which.max)]))
df_select_y0 <- cbind.data.frame(data, Cluster=as.factor(mas$Cluster))
df_select_y0 <- df_select_y0 %>% filter(Cluster %in% c(1,2))
df_select_y0$Cluster <- as.numeric(df_select_y0$Cluster)
df_y0 <- df_select_y0 %>% select(-contains(c("user_uuid","Cluster")))
ss <- silhouette(df_select_y0$Cluster, dist(df_y0, method = "manhattan"))
fviz_silhouette(ss, label = FALSE) +
  theme_bw()+
  theme(panel.grid.major = element_blank(),
        panel.border = element_blank()) + 
  theme(panel.background = element_rect(fill = '#fffff8'),
        plot.background = element_rect(fill = "#fffff8"))
```

<br/>

## Analyse de la stabilité

<br/>

```{r,echo=F, warning=FALSE, message=FALSE}
dist_y0 <- dist(df_y0, method = "manhattan")
dist_y  <- df_select_y %>% select(-contains(c("user_uuid","Cluster"))) %>%
            dist(method = "manhattan")

tab <- tibble(
  stat = names(wcClusterQuality(dist_y0, df_select_y0$Cluster)$stats),
  ECM_incertain_set = wcClusterQuality(dist_y, df_select_y$Cluster)$stats,
  ECM_without_incertain_set = wcClusterQuality(dist_y0, df_select_y0$Cluster)$stats
)
as.data.frame(tab[c(3,4),]) %>%  kable()
```

* R2sq (Coefficient de détermination) : mesure la proportion de la variance totale des données qui est expliquée par le clustering obtenu. On peut voir que la variabilité expliquée par le clustering sans les objects incertains est plus 
élèvé, donc le regroupement obtenu est relativement plus stage.


* CHsq (Calinski-Harabasz index) : basé sur le test de difference de Fisher (la statistiques F), permet de tester la difference entre les individus d'un même clusters par rapport aux clusters voisins. On peut dire que la dissemblance entre les clusters devient très significatives lorsqu'on retir les points incertains.

<br/>

## Analyse de variance (ANOVA)

```{r,echo=F, warning=FALSE, message=FALSE}
df_fusion2$Cluster_ <- ifelse(df_fusion2$Cluster=="2",2,
                              ifelse(df_fusion2$Cluster=="1",1,3))
fmla <- as.formula(paste("Cluster_ ~ ", paste(var, collapse= "+")))
tbl1  <- df_fusion2 %>%
        gtsummary::tbl_summary(by = "Cluster_", include = var) %>%
        gtsummary::add_p(test = everything() ~ "aov")
as_gt(tbl1) %>%  gt::tab_options(table.background.color="#fffff8")
```

```{r,echo=F, warning=FALSE, message=FALSE}

tbl2  <- df_fusion2[df_fusion2$Cluster_==1 | df_fusion2$Cluster_==2,] %>%
  gtsummary::tbl_summary(by = "Cluster_", include = var) %>%
  gtsummary::add_p(test = everything() ~ "aov")
as_gt(tbl2) %>%  gt::tab_options(table.background.color="#fffff8")
```

<br/>

## Analyse de densité



<br/><br/>

# La catégorisation des clusters

L’idée est de comparer les moyennes des variables actives conditionnellement aux clusters et en se basant sur l'explicabilité globale de chaque variables.

```{r,echo=F, warning=FALSE, message=FALSE}
##### categorisation des clusters
stat.comp<-function(x,y){
  #K <-length(unique(y))
  n <-length(x)
  m <-mean(x)
  TSS <-sum((x-m)^2)
  nk<-table(y)
  mk<-tapply(x,y,mean)
  BSS <-sum(nk* (mk-m)^2)
  result<-c(mk,100.0*BSS/TSS)
  #nm <- ifelse(nchar(names(result))<2,)
  K <- length(names(result)[nchar(names(result))<2])
  names(result)[nchar(names(result))<2] <- c(paste("Cl_",1:(K-1)),"% epl.")
  return(result)
}

df_c <- df_select_y
C <-length(unique(df_c$Cluster))
df_c$Cluster <- factor(df_c$Cluster)
contrib <- sapply(df_c[,-which(names(df_c) %in% c("user_uuid","Cluster","Cluster.f"))],
                  stat.comp,y=df_c$Cluster)

#t(as.data.frame(contrib)) %>% kable()
```

```{r,echo=F, warning=FALSE, message=FALSE}
annotation_col <- as.data.frame(contrib[4,])
names(annotation_col) <- "% epl."
ann_colors = list(`% epl.` = c('#D4D8F9','#071DF5'))
p <- pheatmap(contrib[-4,], display_numbers = T, 
         color = colorRampPalette(c('white','red'))(7), angle_col=45,
         fontsize_row=10, fontsize_col=8, number_format="%.2f",
         fontsize_number=10,legend=F,
         annotation_col = annotation_col,
         annotation_legend = TRUE,
         annotation_colors = ann_colors)
grid.draw(rectGrob(gp=gpar(fill="#fffff8", lwd=0)))
grid.draw(p)
```

* Cluster 1 (cl_1) : Douleur chronique associée à la "Triade de l'inconfort" ou "Inconforts chroniques" (en référence à la Fatigue, au Stress et à la Douleur).

* Cluster 2 (cl_2) : Douleur chronique associée à la "Triade du bien-être" ou "Bien-être global chronique" (en référence au Sommeil, au Confort corporel et au Moral).

* Cluster intermédiaire 

<br/>

```{r,echo=F, warning=FALSE, message=FALSE, fig.width=15}
barplot(contrib, 
        legend = rownames(contrib), beside=TRUE, 
        las=1, cex.names=.7,
        args.legend = list(x ='topright',cex=0.6))
```


<br/><br/>

# Analyse descriptive des clusters


## Analyse descriptive des facteurs socio-demogaphiques

<br/>

```{r,echo=F, warning=FALSE, message=FALSE, fig.width=12, fig.height=6}
load("../input/select/tbl_t_perso.Rdata")
as_gt(tbl_t_perso) %>%  gt::tab_options(table.background.color="#fffff8")
```


<br/>

## Analyse descriptive des facteurs cliniques

Pour prendre en compte les mesures répétées des variables explicatives au fil du temps, nous utilisons les tests adaptés suivants :

- Kruskal-Wallis Test pour les variables quantitatives. Le test de Kruskal-Wallis est une alternative non paramétrique au test t pour comparer plus de deux échantilllons appariés.

- Fisher's exact test ou Friedman Rank Sum Test. Le test de Friedman est une alternative non paramétrique au test ANOVA unidirectionnel à mesures répétées. Il étend le test du signe dans la situation où il y a plus de deux groupes à comparer.

<br/>

```{r,echo=F, warning=FALSE, message=FALSE, fig.width=12, fig.height=6}
load("../input/select/tbl_list_auto.Rdata")
as_gt(tbl_list_auto ) %>%  gt::tab_options(table.background.color="#fffff8")
```

<br/>

# Identification des profils patients

* La régression logistique multinomiale permettra d’isoler les effets de chaque variable explicative, c’est-à-dire d’identifier les effets résiduels sur l'appartennance aux clusters. Et pour les variables à plusieurs occurances, nous utiliserons les modèles logistique multinomiale mixtes.


* Sélection de modèles: La phase des tests statistiques ont permis de selectionner les variables qui expliquent significativement l'appartennance à un cluster. Mais cette analyse ne prend pas en compte l'interraction multi-dimension. Et cette interaction peux induire une selection de modèle. Ici on se base sur le critère **AIC**.

<br/>

## Profils socio-démographiques

```{r,echo=F, warning=FALSE, message=FALSE}
load("../input/select/multinomiale_personal_data.Rdata")
anova(regm, regm2, test = "Chisq")
```

Il n’y a pas de différences significatives entre nos deux modèles. Autrement dit, notre second modèle explique tout autant de variance que notre premier modèle, tout en étant plus parcimonieux.

```{r,echo=F, warning=FALSE, message=FALSE, fig.width=12, fig.height=8}
regm2_plot +
  theme(panel.background = element_rect(fill = '#fffff8'),
        plot.background = element_rect(fill = "#fffff8"))
```

<br/>

## Profils sur la perception de la douleur

```{r,echo=F, warning=FALSE, message=FALSE, fig.width=12, fig.height=8}
load("../input/select/multinomiale_perception_data.Rdata")
regmm_plot +
  theme(panel.background = element_rect(fill = '#fffff8'),
        plot.background = element_rect(fill = "#fffff8"))
```

<br/>

## Profils Psychologie

```{r,echo=F, warning=FALSE, message=FALSE, fig.width=12, fig.height=8}
load("../input/select/multinomiale_ProfilPsy_data.Rdata")
regmm_plot +
  theme(panel.background = element_rect(fill = '#fffff8'),
        plot.background = element_rect(fill = "#fffff8"))
```


<br/>

## Profils selon les Comorbidités

```{r,echo=F, warning=FALSE, message=FALSE, fig.width=12, fig.height=8}
load("../input/select/multinomiale_Comorbidites_data.Rdata")
regmm_plot +
  theme(panel.background = element_rect(fill = '#fffff8'),
        plot.background = element_rect(fill = "#fffff8"))
```


<br/>

## Profils selon la Qualité de vie du patient

```{r,echo=F, warning=FALSE, message=FALSE, fig.width=12, fig.height=8}
load("../input/select/multinomiale_QualiteVie_data.Rdata")
regmm2_plot +
  theme(panel.background = element_rect(fill = '#fffff8'),
        plot.background = element_rect(fill = "#fffff8"))
```


<br/>

## D'autres profils

```{r,echo=F, warning=FALSE, message=FALSE, fig.width=12, fig.height=8}
load("../input/select/multinomiale_QuestSpecifiques_data.Rdata")
regmm_plot +
  theme(panel.background = element_rect(fill = '#fffff8'),
        plot.background = element_rect(fill = "#fffff8"))
```
